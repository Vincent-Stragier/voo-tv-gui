r"""GUI allowing to control the electroLABOT.

Compile the GUI:

pyinstaller.exe -F --clean  --add-data './data/;data'
-n "name" --windowed
--icon=package_data/logo.ico .\gui_main.pyw
"""
from settings_ui import Ui_Dialog as SettingDialog
import traceback
from voo_evasion import send_cmd, COMMANDS_HTTP, COMMANDS_RFB
from utils import ensure_path, resource_path, command_to_key
import ctypes
import json
import multiprocessing as mp
import os
# import re
import sys
import threading
# import traceback
import warnings
from functools import partial
from time import sleep, perf_counter_ns

# pylint: disable=E0611
from PyQt6.QtCore import (
    pyqtSlot,
    Qt,
    # pyqtSignal,
    QThreadPool,
    QRunnable,
    QLocale,
    QTranslator,
    QLibraryInfo,
)
from PyQt6.QtGui import (
    QIcon,
    QColor,
    QCloseEvent,
    QValidator,
    QPalette,
)
from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    # QColorDialog,
    QDialog,
    QFileDialog,
)

warnings.simplefilter("ignore", UserWarning)
sys.coinit_flags = 2

# Import Ui_MainWindow class from UiMainApp.py generated by uic module
from remote_ui import Ui_MainWindow  # noqa: E402


check_state_converter = {
    Qt.CheckState.Unchecked: 0,
    Qt.CheckState.PartiallyChecked: 1,
    Qt.CheckState.Checked: 2,
    0: Qt.CheckState.Unchecked,
    1: Qt.CheckState.PartiallyChecked,
    2: Qt.CheckState.Checked
}


def exe_path():
    """ Return the path of the executable or of the script. """
    if hasattr(sys, 'frozen'):
        return os.path.dirname(os.path.abspath(sys.executable))
    return os.path.dirname(os.path.abspath(__file__))


def altered_print(*args, **kwargs) -> None:
    """Freeze the print function to prevent the packaged
    GUI from printing in the console."""
    text = [str(arg) for arg in args]
    separator = kwargs.get('sep', ' ')
    end = kwargs.get('end', '\n')
    file = kwargs.get('file', sys.stdout)
    no_file = 'file' not in kwargs

    if not hasattr(sys, 'frozen') or no_file:
        file.write(separator.join(text) + str(end))


# altered_print = print  # For debugging purposes


SCRIPT_PATH = exe_path()
PREFERENCES_PATH = 'config.json'
PREFERENCES_PATH = os.path.join(SCRIPT_PATH, 'data', PREFERENCES_PATH)
PREFERENCES_PATH = resource_path(PREFERENCES_PATH)

# preferences = {
#     'ip': '192.168.0.179',
#     'port': 5900,
#     'protocol': 'rfb',
# }

# preferences = {
#     'ip': '192.168.0.2',
#     'port': 5900,
#     'protocol': 'rfb',
# }

# Worker class for the QThread handler
# https://stackoverflow.com/questions/50855210/how-to-pass-parameters-into-qrunnable-for-PyQt6


class Worker(QRunnable):  # pylint: disable=too-few-public-methods
    """Worker class to run a function in a QThread."""

    def __init__(self, function, *args, **kwargs):
        super().__init__()
        # Store constructor arguments (re-used for processing)
        self.function = function
        self.args = args
        self.kwargs = kwargs

    @pyqtSlot()
    def run(self):
        """Run the function in the worker."""
        self.function(*self.args, **self.kwargs)


class MainApp(QMainWindow, Ui_MainWindow):
    """
    MainApp class inherit from QMainWindow and from
    Ui_MainWindow class in UiMainApp module.
    """

    def __init__(self):
        """Constructor or the initialiser."""
        QMainWindow.__init__(self)
        # It is imperative to call self.setupUi (self) to initialise the GUI
        # This is defined in gui_autogenerated_template.py file automatically
        self.setupUi(self)
        self.setWindowTitle('VOO .Ã©vasion remote')

        self.command_queue = mp.Queue()

        # Connect the buttons to their respective functions
        self.button_0.clicked.connect(partial(self.send_command, '0'))
        self.button_1.clicked.connect(partial(self.send_command, '1'))
        self.button_2.clicked.connect(partial(self.send_command, '2'))
        self.button_3.clicked.connect(partial(self.send_command, '3'))
        self.button_4.clicked.connect(partial(self.send_command, '4'))
        self.button_5.clicked.connect(partial(self.send_command, '5'))
        self.button_6.clicked.connect(partial(self.send_command, '6'))
        self.button_7.clicked.connect(partial(self.send_command, '7'))
        self.button_8.clicked.connect(partial(self.send_command, '8'))
        self.button_9.clicked.connect(partial(self.send_command, '9'))

        self.button_power_off.clicked.connect(
            partial(self.send_command, 'power_off'))
        self.button_record.clicked.connect(
            partial(self.send_command, 'record'))
        self.button_stop.clicked.connect(partial(self.send_command, 'stop'))
        self.button_fast_reverse.clicked.connect(
            partial(self.send_command, 'fast_reverse'))
        self.button_play_pause.clicked.connect(
            partial(self.send_command, 'play_pause'))
        self.button_fast_forward.clicked.connect(
            partial(self.send_command, 'fast_forward'))

        self.button_tv.clicked.connect(partial(self.send_command, 'tv'))
        self.button_vod.clicked.connect(partial(self.send_command, 'vod'))
        self.button_guide.clicked.connect(partial(self.send_command, 'guide'))
        self.button_info.clicked.connect(partial(self.send_command, 'info'))

        self.button_up.clicked.connect(partial(self.send_command, 'up'))
        self.button_down.clicked.connect(partial(self.send_command, 'down'))
        self.button_left.clicked.connect(partial(self.send_command, 'left'))
        self.button_right.clicked.connect(partial(self.send_command, 'right'))
        self.button_ok.clicked.connect(partial(self.send_command, 'ok'))

        self.button_back.clicked.connect(partial(self.send_command, 'back'))
        self.button_home.clicked.connect(partial(self.send_command, 'home'))

        self.button_volume_down.clicked.connect(
            partial(self.send_command, 'volume_down'))
        self.button_volume_up.clicked.connect(
            partial(self.send_command, 'volume_up'))
        self.button_mute.clicked.connect(partial(self.send_command, 'mute'))

        self.button_red.clicked.connect(partial(self.send_command, 'red_key'))
        self.button_be_tv.clicked.connect(partial(self.send_command, 'be_tv'))

        # self.menuSettings..triggered.connect(self.open_settings)
        self.actionChange_settings.triggered.connect(self.open_settings)
        self.actionReset_settings.triggered.connect(self.reset_settings)
        self.actionRestore_settings_from_file.triggered.connect(
            self.restore_settings)

        self.threadpool = QThreadPool()
        self.threadpool.setMaxThreadCount(4)
        self.command_sender_worker = Worker(self.command_sender_process)
        self.threadpool.start(self.command_sender_worker)
        # self.event_stop = threading.Event()
        self.key_event_worker = Worker(self.keys_events_process)
        self.threadpool.start(self.key_event_worker)

        # send_cmd(ip, port, cmd, protocol="RFB", timeout=None)

        self.keys_events = dict()
        self.lock_keys_events = mp.Lock()
        self.pressed_keys = {}
        self.lock_pressed_keys = mp.Lock()
        # command_queue = mp.Queue(1000)
        self.event_stop = threading.Event()

    def closeEvent(self, a0: QCloseEvent) -> None:
        """Close everything cleanly."""
        self.event_stop.set()
        self.command_queue.close()
        return super().closeEvent(a0)

    def keyPressEvent(self, event) -> None:  # pylint: disable=C0103
        """Intercept the key events.

        Args:
            self: self.
            event: the intercepted event.
        """
        # Close the program
        if event.key() == Qt.Key.Key_Escape:
            self.close()

        # Maximize the window
        if event.key() == Qt.Key.Key_F11:
            if self.isMaximized():
                self.showNormal()
            else:
                self.showMaximized()

        self.lock_keys_events.acquire()
        self.keys_events[event.key()] = {
            'time': perf_counter_ns(),
            'pressed': True}

        self.lock_keys_events.release()

    def keyReleaseEvent(self, event) -> None:  # pylint: disable=C0103
        """Intercept the key events."""
        self.lock_keys_events.acquire()
        self.keys_events[event.key()] = {
            'time': perf_counter_ns(),
            'pressed': False}
        self.lock_keys_events.release()

    def keys_events_process(self) -> None:  # pylint: disable=R0201
        """Process the keys events."""
        old_pressed_keys = set()
        previously_pressed_keys = set()
        newly_pressed_keys = set()

        while not self.event_stop.is_set():
            self.lock_keys_events.acquire()
            self.lock_pressed_keys.acquire()
            self.pressed_keys = {
                key for key, value in self.keys_events.items() if value['pressed']}

            # Detect key pressed/released
            if old_pressed_keys != self.pressed_keys:
                old_pressed_keys = self.pressed_keys
                previously_pressed_keys &= old_pressed_keys
                newly_pressed_keys = old_pressed_keys ^ previously_pressed_keys
                # altered_print(f'{old_pressed_keys = }')
                # altered_print(f'{previously_pressed_keys = }')
                # altered_print(f'{newly_pressed_keys = }')

                if Qt.Key.Key_0 in newly_pressed_keys:
                    self.button_0.click()

                if Qt.Key.Key_1 in newly_pressed_keys:
                    self.button_1.click()

                if Qt.Key.Key_2 in newly_pressed_keys:
                    self.button_2.click()

                if Qt.Key.Key_3 in newly_pressed_keys:
                    self.button_3.click()

                if Qt.Key.Key_4 in newly_pressed_keys:
                    self.button_4.click()

                if Qt.Key.Key_5 in newly_pressed_keys:
                    self.button_5.click()

                if Qt.Key.Key_6 in newly_pressed_keys:
                    self.button_6.click()

                if Qt.Key.Key_7 in newly_pressed_keys:
                    self.button_7.click()

                if Qt.Key.Key_8 in newly_pressed_keys:
                    self.button_8.click()

                if Qt.Key.Key_9 in newly_pressed_keys:
                    self.button_9.click()

                if Qt.Key.Key_Down in newly_pressed_keys:
                    self.button_down.click()

                if Qt.Key.Key_Up in newly_pressed_keys:
                    self.button_up.click()

                if Qt.Key.Key_Left in newly_pressed_keys:
                    self.button_left.click()

                if Qt.Key.Key_Right in newly_pressed_keys:
                    self.button_right.click()

                if Qt.Key.Key_Enter in newly_pressed_keys:
                    self.button_ok.click()

                if Qt.Key.Key_Plus in newly_pressed_keys or Qt.Key.Key_VolumeUp in newly_pressed_keys:
                    self.button_volume_up.click()

                if Qt.Key.Key_Minus in newly_pressed_keys or Qt.Key.Key_VolumeDown in newly_pressed_keys:
                    self.button_volume_down.click()

                if Qt.Key.Key_VolumeMute in newly_pressed_keys:
                    self.button_mute.click()

                if Qt.Key.Key_Play in newly_pressed_keys:
                    self.button_play_pause.click()

                if Qt.Key.Key_Return in newly_pressed_keys:
                    self.button_back.click()

                # Must be last in the branch
                previously_pressed_keys = old_pressed_keys

            # command_keys = set()
            # if Qt.Key.Key_7 in self.pressed_keys or Qt.Key.Key_Home in self.pressed_keys:
            #     command_keys.add('forward_left')
            #     self.forward_left.click()
            # elif Qt.Key.Key_1 in self.pressed_keys or Qt.Key.Key_End in self.pressed_keys:
            #     command_keys.add('backward_left')

            # if Qt.Key.Key_9 in self.pressed_keys or Qt.Key.Key_PageUp in self.pressed_keys:
            #     command_keys.add('forward_right')
            # elif Qt.Key.Key_3 in self.pressed_keys or Qt.Key.Key_PageDown in self.pressed_keys:
            #     command_keys.add('backward_right')

            # # Left/Right
            # if Qt.Key.Key_4 in self.pressed_keys or Qt.Key.Key_Left in self.pressed_keys:
            #     command_keys = set()
            #     command_keys.add('forward_right')
            #     command_keys.add('backward_left')
            # elif Qt.Key.Key_6 in self.pressed_keys or Qt.Key.Key_Right in self.pressed_keys:
            #     command_keys = set()
            #     command_keys.add('forward_left')
            #     command_keys.add('backward_right')

            # # Forward/Backward
            # if Qt.Key.Key_8 in self.pressed_keys or Qt.Key.Key_Up in self.pressed_keys:
            #     command_keys.clear()
            #     command_keys.add('forward_left')
            #     command_keys.add('forward_right')
            # elif Qt.Key.Key_2 in self.pressed_keys or Qt.Key.Key_Down in self.pressed_keys:
            #     command_keys = set()
            #     command_keys.add('backward_left')
            #     command_keys.add('backward_right')

            # if command_keys != old_command_keys:
            #     self.command_queue.put(self.command_encoder(command_keys))
            #     old_command_keys = command_keys

            self.lock_pressed_keys.release()
            self.lock_keys_events.release()
            sleep(0.025)

    # def handle_key_stroke(self, event, pressing: bool) -> None:
    #     altered_print(f'{event.text() = }, {pressing = }')

    # def keyPressEvent(self, event) -> None:  # pylint: disable=C0103
    #     """Intercept the key events.

    #     Args:
    #         self: self.
    #         event: the intercepted event.
    #     """
    #     # Close the program
    #     if event.key() == Qt.Key.Key_Escape:
    #         self.close()

    #     # Maximize the window
    #     elif event.key() == Qt.Key.Key_F11:
    #         if self.isMaximized():
    #             self.showNormal()
    #         else:
    #             self.showMaximized()

    #     else:
    #         self.handle_key_stroke(event, pressing=True)

    # def keyReleaseEvent(self, event) -> None:  # pylint: disable=C0103
    #     """Intercept the key events."""
    #     self.handle_key_stroke(event, pressing=False)

    def send_command(self, command: str):
        # print(command)

        preferences = self.read_preferences()

        command = [command_to_key(command, preferences['protocol'])]

        self.command_queue.put(
            {'command': command, 'ip': preferences['ip'], 'port': preferences['port'], 'protocol': preferences['protocol']})

    def command_sender_process(self):
        """
        This function is the process that will run in the background
        and will send the commands to the TV.
        """
        while not self.event_stop.is_set():
            try:
                command = self.command_queue.get()

                print(f'{command = }')

                send_cmd(
                    ip=command['ip'],
                    port=command['port'],
                    cmd=command['command'],
                    protocol=command['protocol'].upper(),
                    timeout=None,
                )
            except EOFError:
                print('EOFError')
                traceback.print_exc()

            except Exception:
                traceback.print_exc()

    def read_preferences(self, recursive=True):
        """Read the preferences file."""
        try:
            self.preferences = json.load(open(PREFERENCES_PATH, 'r'))
        except (FileNotFoundError, json.decoder.JSONDecodeError):
            self.save_preferences('192.168.0.2', 5900, 'rfb')
            if recursive:
                self.preferences = self.read_preferences(False)
            else:
                self.preferences = None
        return self.preferences

    def open_settings(self):
        """Open the settings window."""
        settings = SettingsWindow(self)
        if settings.exec() == settings.DialogCode.Accepted:
            pass

    def save_preferences(self, ip, port, protocol):
        try:
            ensure_path(os.path.dirname(PREFERENCES_PATH))

            json.dump({
                'ip': ip,
                'port': port,
                'protocol': protocol,
            }, open(PREFERENCES_PATH, 'w'))
        except Exception:
            traceback.print_exc()

    def reset_settings(self):
        """Reset the preferences file."""
        try:
            os.remove(PREFERENCES_PATH)
        except FileNotFoundError:
            pass

        self.read_preferences()

    def restore_settings(self):
        """Restore the preferences file from a file."""
        #     def select_files_browser(self):
        # """Show the files browser."""
        dialog = QFileDialog(self)
        dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)
        # dialog.setDirectory(self.path)

        dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        # Filetype:
        # http://justsolve.archiveteam.org/wiki/NII
        # https://stackoverflow.com/a/27994762
        filters = ["JSON (*.json)", "All Files (*)"]
        dialog.setNameFilters(filters)
        dialog.selectNameFilter(filters[0])
        dialog.setOption(QFileDialog.Option.ShowDirsOnly, False)
        dialog.setViewMode(QFileDialog.ViewMode.Detail)

        if dialog.exec() == QFileDialog.DialogCode.Accepted:
            file = dialog.selectedFiles()[0]

            try:
                preferences = json.load(open(file, 'r'))
                self.save_preferences(
                    preferences['ip'], preferences['port'], preferences['protocol'])
            except Exception:
                traceback.print_exc()

        # self.save_preferences(**settings)
        # try:
        #     os.remove(PREFERENCES_PATH)
        # except FileNotFoundError:
        #     pass

        # self.read_preferences()


class QIntValidatorFixup(QValidator):
    def __init__(self, minimum, maximum, parent):
        QValidator.__init__(self, parent)
        self.minimum = minimum
        self.maximum = maximum

    def validate(self, string, pos):
        if not string.isdigit() and string != '':
            return (QValidator.State.Invalid, string, pos)

        if string.isdigit() and not (self.minimum <= int(string) <= self.maximum):
            if int(string) < self.minimum:
                return (QValidator.State.Acceptable, str(self.minimum), pos)
            return (QValidator.State.Acceptable, str(self.maximum), pos)

        return (QValidator.State.Acceptable, str(int(string)) if string.isdigit() else '', pos)

    def fixup(self, string):
        return str(int(string))


class SettingsWindow(QDialog):
    """Settings dialog."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        # Create an instance of the GUI
        self.ui = SettingDialog()
        # Run the .setupUi() method to show the GUI
        self.ui.setupUi(self)
        self.setWindowTitle('Settings')
        self.ui.ip_0.setValidator(QIntValidatorFixup(0, 255, self))
        self.ui.ip_1.setValidator(QIntValidatorFixup(0, 255, self))
        self.ui.ip_2.setValidator(QIntValidatorFixup(0, 255, self))
        self.ui.ip_3.setValidator(QIntValidatorFixup(0, 255, self))
        self.ui.port.setValidator(QIntValidatorFixup(0, 65535, self))
        self.load_settings()

    def accept(self):
        """Overwrite the accept() method, to validate the settings changes."""
        self.save_changes()
        super().accept()

    def load_settings(self):
        preferences = self.parent.read_preferences()

        self.ui.ip_3.setText(preferences['ip'].split('.')[0])
        self.ui.ip_2.setText(preferences['ip'].split('.')[1])
        self.ui.ip_1.setText(preferences['ip'].split('.')[2])
        self.ui.ip_0.setText(preferences['ip'].split('.')[3])
        self.ui.port.setText(str(preferences['port']))

        self.ui.rfb.setChecked(preferences['protocol'] == 'rfb')
        self.ui.http.setChecked(preferences['protocol'] == 'http')

    def save_changes(self):
        """ Update the edited text. """
        self.parent.save_preferences(
            f'{self.ui.ip_3.text()}.{self.ui.ip_2.text()}.{self.ui.ip_1.text()}.{self.ui.ip_0.text()}',
            int(self.ui.port.text()),
            'rfb' if self.ui.rfb.isChecked() else 'http',
        )

    # def show_error_message_invalid_path(self):
    #     """ Show a warning about the path validity. """
    #     msg = QMessageBox()
    #     msg.setWindowTitle('Unvalid file path')
    #     msg.setIcon(QMessageBox.Icon.Warning)
    #     msg.setText(
    #         'Please select an existing .exe file.')
    #     msg.setStandardButtons(QMessageBox.StandardButton.Ok)
    #     msg.exec()


if __name__ == '__main__':
    # For Windows set AppID to add an Icon in the taskbar
    # https://stackoverflow.com/questions/1551605/how-to-set-applications-taskbar-icon-in-windows-7
    if sys.platform == 'win32':
        from ctypes import wintypes

        APPID = u'vincent_stragier.voo_evasion.v1.0.0'  # arbitrary string
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(APPID)

        lp_buffer = wintypes.LPWSTR()
        ctypes.windll.shell32.GetCurrentProcessExplicitAppUserModelID(
            ctypes.cast(ctypes.byref(lp_buffer), wintypes.LPWSTR))
        # appid = lp_buffer.value
        ctypes.windll.kernel32.LocalFree(lp_buffer)

    app = QApplication(sys.argv)

    # Set the application translations
    language = QLocale.system().name()
    qt_translator = QTranslator()
    qt_translator.load(f'qt_{language}',
                       QLibraryInfo.path(QLibraryInfo.LibraryPath.TranslationsPath))
    app.installTranslator(qt_translator)

    # Dark theme
    # Force the style to be the same on all OSs:
    app.setStyle("Fusion")

    # Now use a palette to switch to dark colors:
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.black)
    palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.black)
    app.setPalette(palette)

    # Launch the main app.
    MyApplication = MainApp()
    MyApplication.show()  # Show the form
    icon_path = resource_path('package_data/icon.ico')
    app.setWindowIcon(QIcon(icon_path))
    MyApplication.setWindowIcon(QIcon(icon_path))
    sys.exit(app.exec())  # Execute the app
